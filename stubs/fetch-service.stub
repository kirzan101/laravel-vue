<?php

namespace {{ namespace }};

use App\Data\PaginateResponse;
use App\Data\CollectionResponse;
use App\Data\ModelResponse;
use App\Helpers\Helper;
use App\Models\{{ base }};
use App\Interfaces\FetchInterfaces\{{ interface }};
use App\Traits\HttpErrorCodeTrait;
use App\Traits\ReturnModelCollectionTrait;
use App\Traits\ReturnModelTrait;
use App\Traits\DefaultPaginateFilterTrait;
use App\Interfaces\CurrentUserInterface;
use App\Interfaces\BaseInterface;
use App\Interfaces\FetchInterfaces\BaseFetchInterface;
use Illuminate\Support\Facades\DB;
use Illuminate\Pagination\Paginator;

class {{ class }} extends BaseFetchService implements {{ interface }}
{
    use HttpErrorCodeTrait,
        ReturnModelCollectionTrait,
        ReturnModelTrait,
        DefaultPaginateFilterTrait;

    /**
     * Fetch a list of {{ description }} with optional search functionality.
     *
     * @param array $request
     * @param bool $isPaginated
     * @param class-string<\Illuminate\Http\Resources\Json\JsonResource>|null $resourceClass
     * @return PaginateResponse|CollectionResponse
     */
    public function index{{ basePlural }}(array $request = [], bool $isPaginated = false, ?string $resourceClass = null): PaginateResponse|CollectionResponse
    {
        try {
            $query = $this->indexQuery({{ base }}::class);

            if ($resourceClass !== null && isset($resourceClass::$relations)) {
                $query->with($resourceClass::$relations ?? []);
            }

            //Uncomment this code if query has a seach functionality
            // //Search filter
            //if (isset($request['search']) && !empty($request['search'])) {
                //$search = $request['search'];
                //$query->where(function ($q) use ($search) {
                //    $q->where('module', 'like', "%{$search}%")
                //        ->orWhere('description', 'like', "%{$search}%");
                //});
            //}

            if ($isPaginated) {
                $allowedFields = (new {{ base }}())->getFillable();

                [
                    'per_page' => $per_page,
                    'sort_by' => $sort_by,
                    'sort' => $sort,
                    'current_page' => $current_page
                ] = $this->paginateFilter($request, $allowedFields);

                // Manually set the current page
                Paginator::currentPageResolver(fn() => $current_page ?? 1);

                ${{ variablePlural }} = $query->orderBy($sort_by, $sort)->paginate($per_page);
                return PaginateResponse::success(200, Helper::SUCCESS, 'Successfully fetched!', ${{ variablePlural }});
            } else {
                ${{ variablePlural }} = $query->get();
                return CollectionResponse::success(200, Helper::SUCCESS, 'Successfully fetched!', ${{ variablePlural }});
            }
        } catch (\Throwable $th) {
            $code = $this->httpCode($th);

            return PaginateResponse::error($code, Helper::ERROR, $th->getMessage());
        }
    }

    /**
     * Fetch a single {{ description }} by ID.
     *
     * @param integer ${{ variable }}Id
     * @param class-string<\Illuminate\Http\Resources\Json\JsonResource>|null $resourceClass
     * @return ModelResponse
     */
    public function show{{ base }}(int ${{ variable }}Id, ?string $resourceClass = null): ModelResponse
    {
        try {
            $query = $this->showQuery({{ base }}::class, ${{ variable }}Id);

            if ($resourceClass !== null && isset($resourceClass::$relations)) {
                $query->with($resourceClass::$relations ?? []);
            }

            $model = $query->firstOrFail();

            return ModelResponse::success(200, Helper::SUCCESS, 'Successfully fetched!', $model, ${{ variable }}Id);
        } catch (\Throwable $th) {
            $code = $this->httpCode($th);

            return ModelResponse::error($code, Helper::ERROR, $th->getMessage());
        }
    }
}
